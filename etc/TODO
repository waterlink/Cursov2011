1) robocore:
   OK	- create interface for z0rch's program and for BTExecutor.java
   OK	- create test classes, that emulates robot
	- code both emulators to be really emulators of something ;)
2) guicore	{winapi for WIN_target} and {opengl or qt for LINUX_target}
	- messaging system
	  TWOK	1) component, form - abstracts, {winapi partially, there still some todo's in code}
	  OK	2) messager - just a class-method delegate
	  OK	3) namer
	  OK	4) message & param interfaces (
				p	text, 
				m	activate, 
				m	select, 
				p	enable, 
				p	size&position, 
				m	mouse, 
				m	paint
			)
  WOK	- client
  WOK	- menu
  WOK	- button
  TOK	- bitbutton
  WOK	- toolbox
  WOK	- view
  WOK	- status
######	- popup, don't need now
  TWOK	- properties
   T	- make this all mess for winapi (W-mark)
	- make this all mess for linux (l-mark)
	- complete all todo's (T-mark)
3) filecore
  OK	- filesystem
  TOK	- file
  WOK	- pather
	- map loading
4) mapcore
  TOK	- work with filecore to read chosen map from file
		created only test class, i don't know format still
  int	- integer coordinate system (or real ?)
  Tabs	- absolute coordinate system (problem with determining start point)
		call NP-area strategy, which determines area template (a piece of a map, rectangle or circular ?),
		searches this template in our map, and
		if there more than one matches, ask user to choose one.
			still it'll be just asking of user
5) fogcore - no module for now, this functionallity would be refactored later to this module
  TOK	- exploration of map
		made this in test map class as 0-value - fogged position 
6) markercore
  AOK	- marker
  TOK	- start point
  TOK	- target
  AOK	- edge
  TOK	- multitarget
  OK	- properties of markers and edges
	- markermap
7) scenariocore
  OK	- vector of commands i think
  OK	- load
  OK	- save
  TOK	- prepare (start point)
  OK	- run
  T?	- cancel (??? maybe ???)
8) strategycore
	- optimalstrategy for targets
		use Markelov's module to determine the best way for each edge
		use z0rch's module to control the robot
	- non-optimalstrategy for targets
		use Manhetton-way, as a way
		use z0rch's module to control the robot
	- optimalstrategy for multitargets
		use Gamilton-way algo to determine best way
		use z0rch's module to control the robot
	- non-optimalstrategy for multitargets
		use geometrical greed algo
		use z0rch's module to control the robot
	- NP area template determinant
		dfs, i think, using BTExecutor to control robot, algo mine
9) utilcore
  OK	- string tokenizer
  OK	- logger
10) maincore
  TOK	- logic
		main program logic

